@using System.Numerics
@using MudBeerPong.Data.Models

<div style="position:relative; width:@(GridWidthPx)px; height:@(GridHeightPx)px; background:#f5f5f5; border-radius:12px; margin:12px auto;"
     @onpointerup="OnPointerUp">

    @if (draggingCup is not null)
    {
        foreach (var spot in OpenSpots)
        {
            var (x, y) = GetCellPosition(spot.row, spot.col);
            <MudPaper Class="cup-spot-available"
                      Style="@($"position: absolute; left: {x}px; top: {y}px; width: {CupSizePx}px; height: {CupSizePx}px; z-index: 2;")">
            </MudPaper>
        }
        <div class="trash-bar"
             @onpointerup="RemoveDraggingCup"
             style="position:absolute; left:0; bottom:0; width:100%; height:48px; display:flex; align-items:center; justify-content:center; z-index:10;">
            <button class="trash-btn" @onclick="RemoveDraggingCup" tabindex="-1" type="button">
                <svg width="28" height="28" viewBox="0 0 24 24" fill="none">
                    <rect x="5" y="7" width="14" height="12" rx="2" fill="#fff" stroke="#fff" stroke-width="1" />
                    <rect x="3" y="5" width="18" height="2" rx="1" fill="#fff" />
                    <path d="M8 10v6M12 10v6M16 10v6" stroke="#e74c3c" stroke-width="2" stroke-linecap="round" />
                    <rect x="5" y="7" width="14" height="12" rx="2" stroke="#e74c3c" stroke-width="2" />
                    <rect x="3" y="5" width="18" height="2" rx="1" stroke="#e74c3c" stroke-width="2" />
                </svg>
            </button>
        </div>
    }

    @foreach (var cup in Cups)
    {
        var (x, y) = GetCellPosition(cup.Row, cup.Column);
        var styleStr = $"left:{x}px; top:{y}px; width:{CupSizePx}px; height:{CupSizePx}px";
        <div class="@(hoveredCup == cup && !EditMode ? "cup cup-hover-highlight" : "cup")"
             style="position:absolute; touch-action:none; user-select:none; @styleStr"
             @onpointerdown="e => OnPointerDown(e, cup)"
             @onclick="() => OnCupClick(cup)"
             @onmouseover="() => OnCupMouseOver(cup)"
             @onmouseout="OnCupMouseOut">
            <svg width="@CupSizePx" height="@CupSizePx">
                <circle cx="@(CupSizePx/2)" cy="@(CupSizePx/2)" r="@(CupSizePx/2-2)" fill="#e74c3c" stroke="#b03a2e" stroke-width="2" />
            </svg>
        </div>
        <MudPaper
            Class="beer-pong-cup"
                  Style="@($"position: absolute; left: {x}px; top: {y}px; width: {CupSizePx}px; height: {CupSizePx}px; border-radius: 50%; background: #e53935; cursor: grab; z-index: 2;")"
                  @onpointerdown="e => OnPointerDown(e, cup)"
                  @onclick="() => OnCupClick(cup)"
                  @onmouseover="() => OnCupMouseOver(cup)"
                  @onmouseout="OnCupMouseOut">
            <span style="color: white; font-weight: bold; line-height: 42px; font-size: 1.2em; text-align: center; display: block; user-select:none;">
                @cup
            </span>
        </MudPaper>
    }
</div>

@code {
    [Parameter] public bool EditMode { get; set; }
    [Parameter] public List<CupModel> Cups { get; set; } = new();
    [Parameter] public EventCallback<List<CupModel>> CupsChanged { get; set; }
    [Parameter] public EventCallback<CupModel> OnCupSelected { get; set; }
    [Parameter] public int? Width { get; set; } // in px
    [Parameter] public int? Height { get; set; } // in px

    private CupModel? draggingCup;
    private CupModel? hoveredCup;
    private Vector2 dragOffset;

    // Grid settings
    private const int GridRows = 8;
    private const int GridColumns = 8;
    private static readonly char[] RowLabels = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H' };
    private const int DefaultGridSize = 384; // px (8*48)
    private int GridWidthPx => Width ?? DefaultGridSize;
    private int GridHeightPx => Height ?? DefaultGridSize;
    private double CellSize => Math.Min((double)GridWidthPx / GridColumns, (double)GridHeightPx / GridRows);
    private int CupSizePx => (int)(CellSize * 0.9); // Cup slightly smaller than cell

    private IEnumerable<(char row, int col)> AllGridCells()
    {
        for (int rowIdx = 0; rowIdx < RowLabels.Length; rowIdx++)
        {
            var row = RowLabels[rowIdx];
            int maxCol = (rowIdx % 2 == 1) ? GridColumns - 1 : GridColumns;
            for (int col = 1; col <= maxCol; col++)
                yield return (row, col);
        }
    }

    private IEnumerable<(char row, int col)> OpenSpots =>
    draggingCup is null
        ? Enumerable.Empty<(char, int)>()
        : AllGridCells().Where(cell =>
            !Cups.Any(c => c != draggingCup && c.Row == cell.row && c.Column == cell.col));

    // Converts a pointer position to a grid cell (row, column)
    private (char row, int col) GetGridCell(double x, double y)
    {
        int rowIdx = (int)Math.Clamp(Math.Round(y / CellSize), 0, GridRows - 1);
        char row = RowLabels[rowIdx];
        int maxCol = (rowIdx % 2 == 1) ? GridColumns - 1 : GridColumns;

        // Offset x by half a cell for odd rows
        // if (rowIdx % 2 == 0)
        // {
        //     x += CellSize / 2;
        // }

        int col = (int)Math.Clamp(Math.Round(x / CellSize), 0, maxCol - 1) + 1;
        return (row, col);
    }

    // Converts a grid cell to a pixel position (for rendering)
    private (double x, double y) GetCellPosition(char row, int col)
    {
        int rowIdx = Array.IndexOf(RowLabels, row);
        // Offset every other row by half a cell
        double x = (col - 1) * CellSize + (CellSize - CupSizePx) / 2;
        if (rowIdx % 2 == 1)
        {
            x += CellSize / 2;
        }
        double y = rowIdx * CellSize + (CellSize - CupSizePx) / 2;
        return (x, y);
    }

    private void OnCupClick(CupModel cup)
    {
        if (!EditMode)
        {
            OnCupSelected.InvokeAsync(cup);
        }
    }

    private void OnPointerDown(PointerEventArgs e, CupModel cup)
    {
        if (!EditMode) return;
        draggingCup = cup;
        dragOffset = new Vector2((float)(e.ClientX - cup.Position.X), (float)(e.ClientY - cup.Position.Y));
        // Listen for move events
        _ = JS.InvokeVoidAsync("beerPongBoard.startDrag", DotNetObjectReference.Create(this));
    }

    private void OnCupMouseOver(CupModel cup)
    {
        if (!EditMode)
            hoveredCup = cup;
    }

    private void OnCupMouseOut()
    {
        hoveredCup = null;
    }

    [JSInvokable]
    public async Task OnPointerMove(double clientX, double clientY)
    {
        if (draggingCup is null) return;

        // Snap to grid
        var (row, col) = GetGridCell(clientX - dragOffset.X, clientY - dragOffset.Y);

        // Prevent moving into an occupied cell (except for the dragging cup itself)
        bool cellOccupied = Cups.Any(c =>
            c != draggingCup &&
            c.Row == row &&
            c.Column == col
        );
        if (cellOccupied) return;

        var (x, y) = GetCellPosition(row, col);
        draggingCup.Position = new Vector2((float)x, (float)y);
        draggingCup.Row = row;
        draggingCup.Column = col;

        await InvokeAsync(StateHasChanged);
    }

    private async Task OnPointerUp()
    {
        if (draggingCup is not null)
        {
            draggingCup = null;
            await CupsChanged.InvokeAsync(Cups);
        }
    }

    private void RemoveDraggingCup()
    {
        if (draggingCup is not null)
        {
            Cups.Remove(draggingCup);
            draggingCup = null;
            CupsChanged.InvokeAsync(Cups);
            StateHasChanged();
        }
    }

    [Inject] private IJSRuntime JS { get; set; } = default!;
}
