@using System.Numerics
@using MudBeerPong.Data.Models

<div style="position:relative; width:@(GridWidthPx)px; height:@(GridHeightPx)px; background:#f5f5f5; border-radius:12px; margin:12px auto;"
@onpointerup="OnPointerUp">

    @if (draggingCup is not null)
    {
        foreach (var spot in OpenSpots)
        {
            var (x, y) = GetCellPosition(spot.row, spot.col);
            <MudPaper Class="cup-spot-available"
            Style="@($"position: absolute; left: {x}px; top: {y}px; width: {CupSizePx}px; height: {CupSizePx}px; z-index: 2;")">
            </MudPaper>
        }
        <div class="trash-bar"
        @onpointerup="RemoveDraggingCup"
        style="position:absolute; left:0; bottom:0; width:100%; height:48px; display:flex; align-items:center; justify-content:center; z-index:10;">
            <button class="trash-btn" @onclick="RemoveDraggingCup" tabindex="-1" type="button">
                <svg width="28" height="28" viewBox="0 0 24 24" fill="none">
                    <rect x="5" y="7" width="14" height="12" rx="2" fill="#fff" stroke="#fff" stroke-width="1" />
                    <rect x="3" y="5" width="18" height="2" rx="1" fill="#fff" />
                    <path d="M8 10v6M12 10v6M16 10v6" stroke="#e74c3c" stroke-width="2" stroke-linecap="round" />
                    <rect x="5" y="7" width="14" height="12" rx="2" stroke="#e74c3c" stroke-width="2" />
                    <rect x="3" y="5" width="18" height="2" rx="1" stroke="#e74c3c" stroke-width="2" />
                </svg>
            </button>
        </div>
    }

    @foreach (var cup in Cups)
    {
        var (x, y) = GetCellPosition(cup.Row, cup.Column);
        var styleStr = $"left:{x}px; top:{y}px; width:{CupSizePx}px; height:{CupSizePx}px";
        <div class="@(hoveredCup == cup && !EditMode ? "cup cup-hover-highlight" : "cup")"
        style="position:absolute; touch-action:none; user-select:none; @styleStr"
        @onpointerdown="e => OnPointerDown(e, cup)"
        @onclick="async () => await OnCupClick(cup)"
        @onmouseover="() => OnCupMouseOver(cup)"
        @onmouseout="OnCupMouseOut">
            <svg width="@CupSizePx" height="@CupSizePx">
                <circle cx="@(CupSizePx/2)" cy="@(CupSizePx/2)" r="@(CupSizePx/2-2)" fill="#e74c3c" stroke="#b03a2e" stroke-width="2" />
            </svg>
        </div>
        <MudPaper
        Class="beer-pong-cup"
        Style="@($"position: absolute; left: {x}px; top: {y}px; width: {CupSizePx}px; height: {CupSizePx}px; border-radius: 50%; background: #e53935; cursor: {CursorStyle}; z-index: 2;")"
        @onpointerdown="e => OnPointerDown(e, cup)"
        @onclick="() => OnCupClick(cup)"
        @onmouseover="() => OnCupMouseOver(cup)"
        @onmouseout="OnCupMouseOut">
            <span style="
                color: white; 
                font-weight: bold; 
                width: 100%; 
                height: 100%; 
                display: flex; 
                align-items: center; 
                justify-content: center; 
                user-select: none; 
                font-size: @(CupSizePx * 0.32)px;">
                @cup
            </span>
        </MudPaper>
    }
</div>

@code {
    [Parameter] public bool EditMode { get; set; }
    [Parameter] public List<CupModel> Cups { get; set; } = new();
    [Parameter] public EventCallback<List<CupModel>> CupsChanged { get; set; }
    [Parameter] public EventCallback<CupModel> OnCupSelected { get; set; }
    [Parameter] public List<CupModel>? CupSizeTemplate { get; set; }
    [Parameter] public int? Width { get; set; } // in px
    [Parameter] public int? Height { get; set; } // in px
    [Parameter] public bool Reverse { get; set; } // Render cups upside down (so they can face the other team)

    private CupModel? draggingCup;
    private CupModel? hoveredCup;
    private Vector2 dragOffset;

    // Grid settings
    private const int DefaultGridRows = 8;
    private const int DefaultGridColumns = 8;
    private static readonly char[] DefaultRowLabels = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H' };

    private int GridRows;
    private int GridColumns;
    private char[] RowLabels = [];

    private const int DefaultGridSize = 288; // px (8*48)
    private int GridWidthPx => Width ?? DefaultGridSize;
    private int GridHeightPx => Height ?? DefaultGridSize;
    private double CellSize => Math.Min((double)GridWidthPx / GridColumns, (double)GridHeightPx / GridRows);
    private int CupSizePx => (int)(CellSize * 0.9); // Cup slightly smaller than cell
    private string CursorStyle => EditMode ? "grab" : "pointer";


    protected override Task OnParametersSetAsync()
    {
        // If in edit mode, use default grid settings
        if (EditMode)
        {
            GridRows = DefaultGridRows;
            GridColumns = DefaultGridColumns;
            RowLabels = DefaultRowLabels;
        }
        else
        {
            // In view mode, use the cups' positions to determine grid size
            var templateCups = CupSizeTemplate ?? Cups;
            if (templateCups.Count > 0)
            {
                var maxRow = templateCups.Max(c => c.Row);
                var maxCol = templateCups.Max(c => c.Column);
                GridRows = Array.IndexOf(DefaultRowLabels, maxRow) + 1;
                GridColumns = maxCol;
                RowLabels = DefaultRowLabels.Take(GridRows).ToArray();
            }
            else
            {
                GridRows = DefaultGridRows;
                GridColumns = DefaultGridColumns;
                RowLabels = DefaultRowLabels;
            }
        }


        return base.OnParametersSetAsync();
    }

    private IEnumerable<(char row, int col)> AllGridCells()
    {
        for (int rowIdx = 0; rowIdx < RowLabels.Length; rowIdx++)
        {
            var row = RowLabels[rowIdx];
            int maxCol = (rowIdx % 2 == 1) ? GridColumns - 1 : GridColumns;
            for (int col = 1; col <= maxCol; col++)
                yield return (row, col);
        }
    }

    private IEnumerable<(char row, int col)> OpenSpots =>
    draggingCup is null
        ? Enumerable.Empty<(char, int)>()
        : AllGridCells().Where(cell =>
            !Cups.Any(c => c != draggingCup && c.Row == cell.row && c.Column == cell.col));

    // Converts a pointer position to a grid cell (row, column)
    private (char row, int col) GetGridCell(double x, double y)
    {
        int rowIdx;
        if (Reverse)
        {
            rowIdx = (int)Math.Clamp(Math.Round(y / CellSize), 0, GridRows - 1);
            rowIdx = GridRows - 1 - rowIdx; // Flip row index
        }
        else
        {
            rowIdx = (int)Math.Clamp(Math.Round(y / CellSize), 0, GridRows - 1);
        }
        char row = RowLabels[rowIdx];
        int maxCol = (rowIdx % 2 == 1) ? GridColumns - 1 : GridColumns;

        int col = (int)Math.Clamp(Math.Round(x / CellSize), 0, maxCol - 1) + 1;
        return (row, col);
    }

    // Converts a grid cell to a pixel position (for rendering)
    private (double x, double y) GetCellPosition(char row, int col)
    {
        int rowIdx = Array.IndexOf(RowLabels, row);
        if (Reverse)
        {
            rowIdx = GridRows - 1 - rowIdx; // Flip row index
        }
        double x = (col - 1) * CellSize + (CellSize - CupSizePx) / 2;

        if (rowIdx % 2 == 1)
        {
            x += CellSize / 2;
        }

        // if (rowIdx % 2 == 1)
        // {
        //     if (Reverse)
        //     {
        //         x -= CellSize / 2; // Offset for odd rows in reverse mode

        //     }
        //     else
        //     {
        //         x += CellSize / 2; // Offset for odd rows in normal mode
        //     }
        // }
        // if (Reverse)
        // {
        //     x += CellSize / 2; // Adjust offset for reverse mode
        // }

        
        double y = rowIdx * CellSize + (CellSize - CupSizePx) / 2;
        return (x, y);
    }

    private async Task OnCupClick(CupModel cup)
    {
        if (!EditMode)
        {
            await OnCupSelected.InvokeAsync(cup);
        }
    }

    private void OnPointerDown(PointerEventArgs e, CupModel cup)
    {
        if (!EditMode) return;
        draggingCup = cup;
        dragOffset = new Vector2((float)(e.ClientX - cup.Position.X), (float)(e.ClientY - cup.Position.Y));
        // Listen for move events
        _ = JS.InvokeVoidAsync("beerPongBoard.startDrag", DotNetObjectReference.Create(this));
    }

    private void OnCupMouseOver(CupModel cup)
    {
        if (!EditMode)
            hoveredCup = cup;
    }

    private void OnCupMouseOut()
    {
        hoveredCup = null;
    }

    [JSInvokable]
    public async Task OnPointerMove(double clientX, double clientY)
    {
        if (draggingCup is null) return;

        // Snap to grid
        var (row, col) = GetGridCell(clientX - dragOffset.X, clientY - dragOffset.Y);

        // Prevent moving into an occupied cell (except for the dragging cup itself)
        bool cellOccupied = Cups.Any(c =>
            c != draggingCup &&
            c.Row == row &&
            c.Column == col
        );
        if (cellOccupied) return;

        var (x, y) = GetCellPosition(row, col);
        draggingCup.Position = new Vector2((float)x, (float)y);
        draggingCup.Row = row;
        draggingCup.Column = col;

        await InvokeAsync(StateHasChanged);
    }

    private async Task OnPointerUp()
    {
        if (draggingCup is not null)
        {
            draggingCup = null;
            await CupsChanged.InvokeAsync(Cups);
        }
    }

    private void RemoveDraggingCup()
    {
        if (draggingCup is not null)
        {
            Cups.Remove(draggingCup);
            draggingCup = null;
            CupsChanged.InvokeAsync(Cups);
            StateHasChanged();
        }
    }

    [Inject] private IJSRuntime JS { get; set; } = default!;
}
